
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pollinations.AI Chat</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
    body {
        font-family: 'Inter', sans-serif;
        background: linear-gradient(135deg, #1e293b, #0f172a);
        height: 100vh;
        width: 100vw;
        overflow: hidden;
    }
    #chatHistory::-webkit-scrollbar {
        width: 8px;
    }
    #chatHistory::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 4px;
    }
    .chat-session-item {
        cursor: pointer;
        padding: 0.75rem;
        border-radius: 0.75rem;
        transition: all 0.2s ease;
        color: #cbd5e1;
        background-color: #1e293b;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .chat-session-item:hover {
        background-color: #334155;
        transform: scale(1.02);
    }
    .chat-session-item.active {
        background-color: #2563eb;
        color: #fff;
        font-weight: bold;
    }
    .user-message {
        background-color: #2563eb;
        color: #fff;
        border-radius: 1rem 1rem 0.25rem 1rem;
    }
    .assistant-message {
        background-color: #334155;
        color: #f1f5e9;
        border-radius: 1rem 1rem 1rem 0.25rem;
    }
    .markdown-body p, .markdown-body li {
        color: #fff;
    }
    .markdown-body pre, .markdown-body code {
        background-color: #1e293b;
        color: #cbd5e0;
    }
    #messageForm {
        position: relative;
    }
    #messageInput {
        padding-right: 7.5rem;
    }
    #submitButton {
        position: absolute;
        right: 1.25rem;
        top: 50%;
        transform: translateY(-50%);
        width: 2.5rem;
        height: 2.5rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #micButton {
        position: absolute;
        right: 4.25rem;
        top: 50%;
        transform: translateY(-50%);
        width: 2.5rem;
        height: 2.5rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #imageAttachButton {
        position: absolute;
        right: 7.25rem;
        top: 50%;
        transform: translateY(-50%);
        width: 2.5rem;
        height: 2.5rem;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #imageAttachButton.disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    #audioVisualizerContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000;
        cursor: pointer;
        background-color: rgba(0,0,0,0.5);
        display: none;
        align-items: center;
        justify-content: center;
    }
    #audioVisualizerContainer.show {
        display: flex;
    }
    .mic-recording {
        color: #ef4444;
    }
    .loading-image-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: #cbd5e1;
        background-color: rgba(51, 65, 85, 0.7);
        backdrop-filter: blur(8px);
        border-radius: 0.75rem;
        transition: all 0.3s ease-in-out;
    }
    .loading-dots {
        display: flex;
        align-items: flex-end;
    }
    .loading-dots span {
        display: inline-block;
        width: 8px;
        height: 8px;
        background-color: #cbd5e1;
        border-radius: 50%;
        margin: 0 2px;
        animation: bounce 0.6s infinite ease-in-out alternate;
    }
    .loading-dots span:nth-child(2) {
        animation-delay: 0.1s;
    }
    .loading-dots span:nth-child(3) {
        animation-delay: 0.2s;
    }
    @keyframes bounce {
        from { transform: translateY(0); }
        to { transform: translateY(-8px); }
    }

    /* Styles for the streaming toggle switch */
    .toggle-switch-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #475569;
      transition: .4s;
      border-radius: 34px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .toggle-slider {
      background-color: #2563eb;
    }
    input:focus + .toggle-slider {
      box-shadow: 0 0 1px #2563eb;
    }
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    /* Styles for the thinking dropdown */
    details.thinking-dropdown {
        margin-top: 1rem;
        background-color: #1e293b;
        border-radius: 0.5rem;
        padding: 0.5rem;
        border: 1px solid #334155;
    }
    details.thinking-dropdown summary {
        cursor: pointer;
        color: #94a3b8;
        font-size: 0.875rem;
        font-weight: 500;
        list-style: none;
        position: relative;
        padding-left: 1.5rem;
    }
    details.thinking-dropdown summary::before {
        content: '\25b6';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%) rotate(0deg);
        transition: transform 0.2s ease;
    }
    details.thinking-dropdown[open] summary::before {
        transform: translateY(-50%) rotate(90deg);
    }
    details.thinking-dropdown .thinking-content {
        padding-top: 0.5rem;
        border-top: 1px solid #334155;
        margin-top: 0.5rem;
    }
    
    /* New compact model selector styles */
    .model-pills-container {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    .model-pill {
        padding: 0.5rem 1rem;
        border-radius: 9999px;
        background-color: #1e293b;
        color: #cbd5e1;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid #334155;
        font-size: 0.875rem;
        white-space: nowrap;
    }
    .model-pill:hover {
        background-color: #334155;
    }
    .model-pill.active {
        background-color: #2563eb;
        color: white;
        border-color: #3b82f6;
    }
    .model-pill .model-icon {
        margin-right: 0.25rem;
    }
</style>
</head>
<body>
    <div class="flex h-screen w-screen bg-slate-900/80 backdrop-blur-md">
        <div class="w-80 min-w-64 flex flex-col border-r border-slate-800 flex-shrink-0">
            <div class="p-3 border-b border-slate-800 bg-slate-800/30">
                <button id="newChatButton" class="w-full py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg shadow transition flex items-center justify-center">
                    <i class="fa-solid fa-plus"></i>
                </button>
            </div>
            <div id="chatSessionsList" class="flex-grow overflow-y-auto p-3 space-y-2">
            </div>
        </div>
        <div class="flex flex-col flex-grow min-w-0">
            <div class="p-4 bg-slate-800/30 border-b border-slate-800 flex justify-between items-center flex-wrap gap-4">
<div class="flex-1 mr-4 min-w-0" id="modelSelectorContainer">
    <label class="block text-sm font-medium text-slate-300 mb-1">Model:</label>
    <div id="modelPills" class="model-pills-container hidden">
        <div class="model-pill" data-model="deepseek-r1-distill-llama-70b">
            <i class="fas fa-brain model-icon"></i> DeepSeek
        </div>
        <div class="model-pill" data-model="openai-fast">
            <i class="fas fa-bolt model-icon"></i> GPT-4.1
        </div>
        <div class="model-pill" data-model="evil">
            <i class="fas fa-skull model-icon"></i> Evil [18+]
        </div>
        <div class="model-pill" data-model="unity">
            <i class="fas fa-gamepad model-icon"></i> Unity [18+]
        </div>
    </div>
    <select id="modelSelect" class="w-full p-2 bg-slate-800 text-white rounded-md border border-slate-700 focus:ring-2 focus:ring-blue-500"></select>
</div>
                <div class="toggle-switch-container">
                    <label class="text-sm font-medium text-slate-300 whitespace-nowrap">Streaming</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="streamingSwitch">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-switch-container">
                    <label class="text-sm font-medium text-slate-300 whitespace-nowrap">Advanced Mode</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="advancedModeSwitch">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div id="chatHistory" class="flex-grow overflow-y-auto overflow-x-hidden p-4 space-y-4 bg-slate-900/60 flex flex-col transition-all duration-300">
            </div>
            <form id="messageForm" class="flex items-center gap-2 p-4 border-t border-slate-800 bg-slate-800/40 min-w-0 flex-col">
                <div id="imagePreviewContainer" class="w-full flex items-center justify-between p-2 mb-2 bg-slate-700 rounded-lg hidden">
                    <div class="flex items-center gap-2">
                        <img id="imagePreview" src="" class="h-12 w-auto object-contain rounded-md" alt="Attached Image Preview">
                        <span id="imageFileName" class="text-white text-sm"></span>
                    </div>
                    <button type="button" id="removeImageButton" class="text-red-400 hover:text-red-600 transition">
                        <i class="fa-solid fa-times"></i>
                    </button>
                </div>
                <div class="w-full flex items-center gap-2">
                    <input type="text" id="messageInput" placeholder="Type a message..." class="flex-grow p-3 rounded-lg bg-slate-800 text-white border border-slate-700 focus:ring-2 focus:ring-blue-500 min-w-0" />
                    <input type="file" id="imageInput" accept="image/*" class="hidden">
                    <button type="button" id="imageAttachButton" class="bg-slate-700 hover:bg-slate-600 text-white rounded-full shadow transition" aria-label="Attach an image">
                        <i class="fa-solid fa-camera"></i>
                    </button>
                    <button type="button" id="micButton" class="bg-slate-700 hover:bg-slate-600 text-white rounded-full shadow transition" aria-label="Start voice input">
                        <i class="fa-solid fa-microphone"></i>
                    </button>
                    <button type="submit" id="submitButton" class="bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow transition">
                        <i class="fa-solid fa-paper-plane"></i>
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="audioVisualizerContainer">
        <canvas id="audioVisualizerCanvas"></canvas>
    </div>

    <div id="imageModal" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-[1000] hidden">
        <div class="relative bg-slate-800 rounded-lg p-4 max-w-5xl mx-auto max-h-[90vh] flex flex-col">
            <button id="closeModalButton" class="absolute top-2 right-2 text-white bg-red-600 hover:bg-red-700 rounded-full w-8 h-8 flex items-center justify-center text-lg z-10">
                <i class="fa-solid fa-times"></i>
            </button>
            <img id="modalImage" src="" alt="Full size generated image" class="max-h-[70vh] w-auto rounded-lg shadow-xl object-contain">
            <div class="mt-4 flex justify-center">
                <button id="downloadButton" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg shadow-md flex items-center gap-2 transition">
                    <i class="fa-solid fa-download"></i>
                    Download Image
                </button>
            </div>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
const models = [
    { "name": "deepseek-r1-distill-llama-70b", "description": "DeepSeek R1 Distill Llama 70B (Groq)", "type": "groq", "category": "basic", "friendlyName": "DeepSeek R1 Distill (Reasoning)" },
    { "name": "openai-fast", "description": "OpenAI GPT-4.1 Nano", "type": "pollinations", "category": "basic", "friendlyName": "GPT-4.1 Nano" },
	{ "name": "evil", "description": "Evil AI", "type": "pollinations", "category": "basic", "friendlyName": "Evil" },
    { "name": "unity", "description": "Unity Unrestricted Agent", "type": "pollinations", "category": "basic", "friendlyName": "Unity" },
        { "name": "gpt-5-nano", "description": "OpenAI GPT-5 Nano", "type": "pollinations", "category": "advanced" },
        { "name": "llama-fast-roblox", "description": "Llama 3.2 1B", "type": "pollinations", "category": "advanced" },
        { "name": "llama-roblox", "description": "Llama 3.1 8B Instruct", "type": "pollinations", "category": "advanced" },
        { "name": "llamascout", "description": "Llama 4 Scout 17B", "type": "pollinations", "category": "advanced" },
        { "name": "mistral", "description": "Mistral Small 3.1 24B", "type": "pollinations", "category": "advanced" },
        { "name": "mistral-nemo-roblox", "description": "Mistral Nemo Instruct 2407 (Nebius)", "type": "pollinations", "category": "advanced" },
        { "name": "mistral-roblox", "description": "Mistral Small 3.1 24B", "type": "pollinations", "category": "advanced" },
        { "name": "nova-fast", "description": "Amazon Nova Micro (Bedrock)", "type": "pollinations", "category": "advanced" },
        { "name": "openai", "description": "OpenAI GPT-4.1 Nano", "type": "pollinations", "category": "advanced" },
        { "name": "openai-audio", "description": "OpenAI GPT-4o Mini Audio Preview", "type": "pollinations", "category": "advanced" },
        { "name": "openai-fast", "description": "OpenAI GPT-4.1 Nano", "type": "pollinations", "category": "advanced" },
        { "name": "openai-large", "description": "OpenAI GPT-4.1", "type": "pollinations", "category": "advanced" },
        { "name": "openai-roblox", "description": "OpenAI GPT-4.1 Nano", "type": "pollinations", "category": "advanced" },
        { "name": "qwen-coder", "description": "Qwen 2.5 Coder 32B", "type": "pollinations", "category": "advanced" },
        { "name": "bidara", "description": "BIDARA (Biomimetic Designer and Research Assistant by NASA)", "type": "pollinations", "category": "advanced" },
        { "name": "hypnosis-tracy", "description": "Hypnosis Tracy", "type": "pollinations", "category": "advanced" },
        { "name": "midijourney", "description": "MIDIjourney", "type": "pollinations", "category": "advanced" },
        { "name": "mirexa", "description": "Mirexa AI Companion", "type": "pollinations", "category": "advanced" },
        { "name": "rtist", "description": "Rtist", "type": "pollinations", "category": "advanced" },
        { "name": "sur", "description": "Sur AI Assistant", "type": "pollinations", "category": "advanced" },
    ];

    function populateModelSelect() {
        const modelSelect = document.getElementById("modelSelect");
        modelSelect.innerHTML = '';
        models.forEach(model => {
            const option = document.createElement("option");
            option.value = model.name;
            option.textContent = `${model.name} - ${model.description}`;
            modelSelect.appendChild(option);
        });
    }

    const CHAT_KEY = "pollinationsAIChatSessions";
    let chatSessions = {};
    let currentChatId = null;

    function loadChatSessions() {
        const savedSessions = localStorage.getItem(CHAT_KEY);
        if (savedSessions) {
            chatSessions = JSON.parse(savedSessions);
        }
        if (Object.keys(chatSessions).length === 0) {
            createNewChat();
        } else {
            const lastSessionId = localStorage.getItem('currentChatId');
            currentChatId = lastSessionId && chatSessions[lastSessionId] ? lastSessionId : Object.keys(chatSessions)[0];
            renderChatSessionsList();
            renderChat();
        }
    }

    function saveChatSessions() {
        localStorage.setItem(CHAT_KEY, JSON.stringify(chatSessions));
        localStorage.setItem('currentChatId', currentChatId);
    }

    function renderChatSessionsList() {
        const chatSessionsListDiv = document.getElementById("chatSessionsList");
        chatSessionsListDiv.innerHTML = '';
        Object.keys(chatSessions).forEach(id => {
            const session = chatSessions[id];
            const chatTitle = session.length > 0 ? session[0].content.substring(0, 30) + '...' : 'New Chat';
            const sessionElement = document.createElement("div");
            sessionElement.className = `chat-session-item ${id === currentChatId ? 'active' : ''}`;
            
            const titleSpan = document.createElement('span');
            titleSpan.className = 'flex-grow overflow-hidden text-ellipsis whitespace-nowrap';
            titleSpan.textContent = chatTitle;

            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '<i class="fa-solid fa-trash-can text-rose-400 hover:text-rose-600 transition"></i>';
            deleteButton.title = 'Delete this chat';
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteChat(id);
            });

            sessionElement.appendChild(titleSpan);
            sessionElement.appendChild(deleteButton);
            
            sessionElement.addEventListener('click', () => switchChat(id));
            chatSessionsListDiv.appendChild(sessionElement);
        });
    }
    
    // Toggle model visibility based on Advanced Mode
    function updateModelList() {
        const advancedMode = document.getElementById('advancedModeSwitch').checked;
        const modelSelect = document.getElementById('modelSelect');
        const modelPills = document.getElementById('modelPills');
        const currentModel = modelSelect.value;

        // Toggle between the two UI elements
        if (advancedMode) {
            modelPills.classList.add('hidden');
            modelSelect.classList.remove('hidden');
        } else {
            modelSelect.classList.add('hidden');
            modelPills.classList.remove('hidden');
        }

        // Update the model select options
        modelSelect.innerHTML = ''; // Clear existing options
        
        models.forEach(model => {
            if (advancedMode || model.category === "basic") {
                const option = document.createElement("option");
                option.value = model.name;
                option.textContent = advancedMode 
                    ? `${model.name} - ${model.description}` 
                    : model.friendlyName || model.description;
                modelSelect.appendChild(option);
            }
        });

        // Update the active pill
        document.querySelectorAll('.model-pill').forEach(pill => {
            pill.classList.remove('active');
            if (pill.dataset.model === currentModel) {
                pill.classList.add('active');
            }
        });

        // If current model is hidden, switch to DeepSeek
        if (!advancedMode && !models.some(m => m.name === currentModel && m.category === "basic")) {
            modelSelect.value = "deepseek-r1-distill-llama-70b";
            document.querySelector('.model-pill[data-model="deepseek-r1-distill-llama-70b"]').classList.add('active');
        }
    }

    // Initialize Advanced Mode (off by default)
    function initAdvancedMode() {
        document.getElementById('advancedModeSwitch').addEventListener('change', updateModelList);
        document.getElementById('advancedModeSwitch').checked = false; // Default OFF
        
        // Add event listeners for model pills
        document.querySelectorAll('.model-pill').forEach(pill => {
            pill.addEventListener('click', () => {
                const model = pill.dataset.model;
                document.querySelectorAll('.model-pill').forEach(p => p.classList.remove('active'));
                pill.classList.add('active');
                document.getElementById('modelSelect').value = model;
                
                // Update image upload button state
                const selectedModelDetails = models.find(m => m.name === model);
                const imageAttachButton = document.getElementById('imageAttachButton');
                if (selectedModelDetails && selectedModelDetails.type === 'groq') {
                    imageAttachButton.disabled = true;
                    imageAttachButton.classList.add('disabled');
                } else {
                    imageAttachButton.disabled = false;
                    imageAttachButton.classList.remove('disabled');
                }
            });
        });
        
        updateModelList(); // Apply initial filter
    }

    function switchChat(id) {
        if (currentChatId !== id) {
            currentChatId = id;
            saveChatSessions();
            renderChatSessionsList();
            renderChat();
        }
    }

    function createNewChat() {
        const newId = `chat-${Date.now()}`;
        chatSessions[newId] = [];
        currentChatId = newId;
        saveChatSessions();
        renderChatSessionsList();
        renderChat();
    }
    
    function deleteChat(idToDelete) {
        if (Object.keys(chatSessions).length > 1) {
            delete chatSessions[idToDelete];
            if (currentChatId === idToDelete) {
                currentChatId = Object.keys(chatSessions)[0];
            }
            saveChatSessions();
            renderChatSessionsList();
            renderChat();
        } else {
            delete chatSessions[idToDelete];
            createNewChat();
        }
    }

    // New function to create and append a single message element
    function createAndAppendMessageElement(msg, id = null) {
        const chatHistoryDiv = document.getElementById("chatHistory");
        const messageElement = document.createElement("div");
        
        if (id) {
            messageElement.id = id;
        }

        if (msg.role === 'user') {
            messageElement.className = `p-3 shadow-md max-w-[80%] self-end user-message break-words`;
            
            let contentHtml = `<p class="font-bold mb-1">You:</p>${marked.parse(msg.content)}`;
            if (msg.imageData) {
                contentHtml += `<div class="mt-2"><img src="${msg.imageData.data}" class="max-w-full h-auto rounded-lg shadow-md" /></div>`;
            }

            messageElement.innerHTML = contentHtml;
        } else if (msg.role === 'assistant') {
            messageElement.className = `p-3 shadow-md max-w-[80%] self-start assistant-message break-words`;
            
            if (msg.content.startsWith('loading-image-')) {
                messageElement.classList.add('flex', 'items-center', 'justify-center', 'min-h-[150px]');
                messageElement.innerHTML = `
                    <div class="loading-image-container p-4">
                        <i class="fa-solid fa-spinner fa-spin text-4xl text-blue-400 mb-2"></i>
                        <p class="text-sm font-medium">Generating image...</p>
                    </div>
                `;
            } else if (msg.content === 'loading' || msg.content === 'streaming_loading') {
                // Updated HTML for the bouncing dots animation for both loading states
                messageElement.innerHTML = `
                    <p class="font-bold mb-1">AeosAI:</p>
                    <div class="streaming-content markdown-body">
                        <div class="loading-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                `;
            } else {
                // Modified to handle generations
                const displayContent = msg.generations && msg.generations[msg.currentGenerationIndex] ? msg.generations[msg.currentGenerationIndex].content : msg.content;
                const displayThinking = msg.generations && msg.generations[msg.currentGenerationIndex] ? msg.generations[msg.currentGenerationIndex].thinkingContent : msg.thinkingContent;
                
                const contentHtml = `<p class="font-bold mb-1">AeosAI:</p><div class="markdown-body">${marked.parse(displayContent)}</div>`;
                messageElement.innerHTML = contentHtml;

                if (displayThinking) {
                    const thinkingDropdown = document.createElement('details');
                    thinkingDropdown.className = 'thinking-dropdown';
                    thinkingDropdown.innerHTML = `
                        <summary>Show thought process</summary>
                        <div class="thinking-content markdown-body">${marked.parse(displayThinking)}</div>
                    `;
                    messageElement.appendChild(thinkingDropdown);
                }

                // Add regeneration and navigation buttons
                const actionContainer = document.createElement('div');
                actionContainer.className = 'flex items-center space-x-2 mt-2';
                
                // Regenerate button
                const regenerateButton = document.createElement('button');
                regenerateButton.className = 'text-slate-400 hover:text-slate-200 transition';
                regenerateButton.innerHTML = '<i class="fa-solid fa-arrows-rotate"></i>';
                regenerateButton.title = 'Regenerate response';
                regenerateButton.onclick = () => regenerateResponse(messageElement.id);
                actionContainer.appendChild(regenerateButton);

                // Navigation buttons
                if (msg.generations && msg.generations.length > 1) {
                    const navSpan = document.createElement('span');
                    navSpan.className = 'flex items-center space-x-2';
                    
                    const prevButton = document.createElement('button');
                    prevButton.className = `text-slate-400 hover:text-slate-200 transition ${msg.currentGenerationIndex === 0 ? 'opacity-50 cursor-not-allowed' : ''}`;
                    prevButton.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                    prevButton.title = 'Previous generation';
                    prevButton.disabled = msg.currentGenerationIndex === 0;
                    prevButton.onclick = () => showPreviousGeneration(messageElement.id);
                    navSpan.appendChild(prevButton);
                    
                    const counter = document.createElement('span');
                    counter.className = 'text-xs text-slate-500';
                    counter.textContent = `${msg.currentGenerationIndex + 1} / ${msg.generations.length}`;
                    navSpan.appendChild(counter);

                    const nextButton = document.createElement('button');
                    nextButton.className = `text-slate-400 hover:text-slate-200 transition ${msg.currentGenerationIndex === msg.generations.length - 1 ? 'opacity-50 cursor-not-allowed' : ''}`;
                    nextButton.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                    nextButton.title = 'Next generation';
                    nextButton.disabled = msg.currentGenerationIndex === msg.generations.length - 1;
                    nextButton.onclick = () => showNextGeneration(messageElement.id);
                    navSpan.appendChild(nextButton);

                    actionContainer.appendChild(navSpan);
                }

                messageElement.appendChild(actionContainer);
            }

            // Find and style images after parsing
            const images = messageElement.querySelectorAll('img');
            images.forEach(img => {
                img.classList.add('rounded-lg', 'shadow-lg', 'mt-2', 'cursor-pointer', 'max-w-full', 'max-h-64', 'object-contain');
                
                img.addEventListener('click', () => {
                    const modalImage = document.getElementById('modalImage');
                    modalImage.src = img.src;
                    document.getElementById('imageModal').classList.remove('hidden');
                });

                img.onerror = () => {
                    img.onerror = null;
                    img.src = 'https://placehold.co/400x300/e2e8f0/1a202c?text=Image+Failed+to+Load';
                    img.style.cursor = 'default';
                    img.onclick = null;
                };
            });
        }
        chatHistoryDiv.appendChild(messageElement);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    // Function to update the content of a specific message element
    function updateMessageElement(id, msg) {
        const messageElement = document.getElementById(id);
        if (messageElement) {
            // Remove loading styles and content
            messageElement.classList.remove('flex', 'items-center', 'justify-center', 'min-h-[150px]');
            
            // Clear existing content to rebuild
            messageElement.innerHTML = '';
            
            // Add main content
            const mainContentDiv = document.createElement('div');
            // Get the current generation to display
            const displayContent = msg.generations && msg.generations[msg.currentGenerationIndex] ? msg.generations[msg.currentGenerationIndex].content : msg.content;
            const displayThinking = msg.generations && msg.generations[msg.currentGenerationIndex] ? msg.generations[msg.currentGenerationIndex].thinkingContent : msg.thinkingContent;
            
            mainContentDiv.innerHTML = `<p class="font-bold mb-1">AeosAI:</p><div class="markdown-body">${marked.parse(displayContent)}</div>`;
            messageElement.appendChild(mainContentDiv);
            
            // Re-apply image styling and event listeners
            const images = messageElement.querySelectorAll('img');
            images.forEach(img => {
                img.classList.add('rounded-lg', 'shadow-lg', 'mt-2', 'cursor-pointer', 'max-w-full', 'max-h-64', 'object-contain');
                img.addEventListener('click', () => {
                    const modalImage = document.getElementById('modalImage');
                    modalImage.src = img.src;
                    document.getElementById('imageModal').classList.remove('hidden');
                });
                img.onerror = () => {
                    img.onerror = null;
                    img.src = 'https://placehold.co/400x300/e2e8f0/1a202c?text=Image+Failed+to+Load';
                    img.style.cursor = 'default';
                    img.onclick = null;
                };
            });

            // Add the thinking dropdown if the message has thinking content
            if (displayThinking) {
                const thinkingDropdown = document.createElement('details');
                thinkingDropdown.className = 'thinking-dropdown';
                thinkingDropdown.innerHTML = `
                    <summary>Show thought process</summary>
                    <div class="thinking-content markdown-body">${marked.parse(displayThinking)}</div>
                `;
                messageElement.appendChild(thinkingDropdown);
            }

            // Add regeneration and navigation buttons
            const actionContainer = document.createElement('div');
            actionContainer.className = 'flex items-center space-x-2 mt-2';
            
            // Regenerate button
            const regenerateButton = document.createElement('button');
            regenerateButton.className = 'text-slate-400 hover:text-slate-200 transition';
            regenerateButton.innerHTML = '<i class="fa-solid fa-arrows-rotate"></i>';
            regenerateButton.title = 'Regenerate response';
            regenerateButton.onclick = () => regenerateResponse(messageElement.id);
            actionContainer.appendChild(regenerateButton);

            // Navigation buttons
            if (msg.generations && msg.generations.length > 1) {
                const navSpan = document.createElement('span');
                navSpan.className = 'flex items-center space-x-2';
                
                const prevButton = document.createElement('button');
                prevButton.className = `text-slate-400 hover:text-slate-200 transition ${msg.currentGenerationIndex === 0 ? 'opacity-50 cursor-not-allowed' : ''}`;
                prevButton.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                prevButton.title = 'Previous generation';
                prevButton.disabled = msg.currentGenerationIndex === 0;
                prevButton.onclick = () => showPreviousGeneration(messageElement.id);
                navSpan.appendChild(prevButton);
                
                const counter = document.createElement('span');
                counter.className = 'text-xs text-slate-500';
                counter.textContent = `${msg.currentGenerationIndex + 1} / ${msg.generations.length}`;
                navSpan.appendChild(counter);

                const nextButton = document.createElement('button');
                nextButton.className = `text-slate-400 hover:text-slate-200 transition ${msg.currentGenerationIndex === msg.generations.length - 1 ? 'opacity-50 cursor-not-allowed' : ''}`;
                nextButton.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                nextButton.title = 'Next generation';
                nextButton.disabled = msg.currentGenerationIndex === msg.generations.length - 1;
                nextButton.onclick = () => showNextGeneration(messageElement.id);
                navSpan.appendChild(nextButton);

                actionContainer.appendChild(navSpan);
            }

            messageElement.appendChild(actionContainer);
        }
        document.getElementById("chatHistory").scrollTop = document.getElementById("chatHistory").scrollHeight;
    }

    // Renders the full chat history (only called on load or session switch)
    function renderChat() {
        const chatHistoryDiv = document.getElementById("chatHistory");
        chatHistoryDiv.innerHTML = '';
        const currentHistory = chatSessions[currentChatId] || [];
        currentHistory.forEach((msg, index) => {
            // Give each assistant message a unique ID for regeneration/navigation
            const id = (msg.role === 'assistant') ? `message-${index}` : null;
            createAndAppendMessageElement(msg, id);
        });
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    /**
     * Checks an image URL for specific parameters and adds them if they are missing.
     * @param {string} url The original image URL.
     * @param {number} seed The current seed value to add if missing.
     * @returns {string} The modified URL.
     */
    function addDefaultUrlParams(url, seed) {
      try {
        const urlObj = new URL(url);
        const params = urlObj.searchParams;

        if (!params.has('seed')) {
          params.set('seed', seed);
        }

        if (!params.has('nologo')) {
          params.set('nologo', 'true');
        }

        return urlObj.toString();
      } catch (e) {
        console.error('Invalid URL:', url, e);
        return url;
      }
    }

    async function submitForm(event) {
        event.preventDefault();
        const model = document.getElementById("modelSelect").value;
        const messageInput = document.getElementById("messageInput");
        const streamingEnabled = document.getElementById("streamingSwitch").checked;
        const messageContent = messageInput.value.trim();
        const attachedImage = document.getElementById("imageInput").files[0];
        
        const selectedModelDetails = models.find(m => m.name === model);
        const isGroqModel = selectedModelDetails && selectedModelDetails.type === "groq";

        if (isGroqModel && attachedImage) {
            showCustomAlert("Image uploads are not supported for the selected model.");
            document.getElementById('imageInput').value = '';
            document.getElementById('imagePreviewContainer').classList.add('hidden');
            return;
        }

        if (!messageContent && !attachedImage) return;

        let currentHistory = chatSessions[currentChatId] || [];

        const userMessage = { role: "user", content: messageContent };
        if (attachedImage) {
            try {
                const base64Data = await convertImageToBase64(attachedImage);
                userMessage.imageData = { mimeType: attachedImage.type, data: base64Data };
            } catch (e) {
                console.error("Failed to read image file:", e);
                showCustomAlert("Error: Could not read image file. Please try again.");
                return;
            }
        }
        
        currentHistory.push(userMessage);
        createAndAppendMessageElement(userMessage);
        messageInput.value = "";
        
        // Clear the image preview after sending
        if (attachedImage) {
            document.getElementById('imageInput').value = '';
            document.getElementById('imagePreviewContainer').classList.add('hidden');
        }

        const placeholderId = `message-${currentHistory.length}`;
        const placeholderMessage = { role: "assistant", content: streamingEnabled ? 'streaming_loading' : 'loading' };
        currentHistory.push(placeholderMessage);
        createAndAppendMessageElement(placeholderMessage, placeholderId);

        saveChatSessions();

        const submitButton = document.getElementById("submitButton");
        submitButton.disabled = true;
        submitButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
        
        try {
            const apiMessages = constructApiMessages(isGroqModel, userMessage);
            if (isGroqModel) {
                await handleGroqApiCall(model, streamingEnabled, apiMessages, placeholderId);
            } else {
                await handlePollinationsApiCall(model, streamingEnabled, apiMessages, placeholderId);
            }
        } catch (error) {
            const errorMessage = `Error: ${error.message}`;
            const placeholderIndex = chatSessions[currentChatId].findIndex((msg, index) => `message-${index}` === placeholderId);
            if (placeholderIndex !== -1) {
                chatSessions[currentChatId][placeholderIndex] = { role: "assistant", content: errorMessage };
                updateMessageElement(placeholderId, { role: "assistant", content: errorMessage });
            } else {
                chatSessions[currentChatId].push({ role: "assistant", content: errorMessage });
                createAndAppendMessageElement({ role: "assistant", content: errorMessage });
            }
            saveChatSessions();
            console.error("API call failed:", error);
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        }
    }

    async function handlePollinationsApiCall(model, streamingEnabled, apiMessages, placeholderId) {
        const apiUrl = "https://text.pollinations.ai/openai";
        const apiToken = "G8f6YS3lJnS7KK2I";
        let temperature = model === "gpt-5-nano" ? 1 : 0.7;

        let seed = parseInt(localStorage.getItem('seed')) || 1;
        seed++;
        localStorage.setItem('seed', seed);
        
        const requestBody = {
            "model": model,
            "messages": apiMessages,
            "temperature": temperature,
            "stream": streamingEnabled,
            "seed": seed
        };
        // Removed `private: false` as it is not supported

        if (streamingEnabled) {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiToken}`
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.details.error.message}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder("utf-8");
            let fullResponse = "";
            const messageElement = document.getElementById(placeholderId);
            if (!messageElement) throw new Error("Could not find message element for streaming.");
            
            const loadingDots = messageElement.querySelector('.loading-dots');
            const streamingContent = messageElement.querySelector('.streaming-content');
            let isFirstChunk = true;

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                const lines = chunk.split("\n");
                for (const line of lines) {
                    if (line.startsWith("data: ")) {
                        const data = line.substring(6);
                        if (data === "[DONE]") continue;
                        try {
                            const json = JSON.parse(data);
                            if (json.choices && json.choices[0].delta && json.choices[0].delta.content) {
                                if (isFirstChunk) {
                                    if (loadingDots) {
                                        loadingDots.remove();
                                    }
                                    isFirstChunk = false;
                                }
                                fullResponse += json.choices[0].delta.content;
                                streamingContent.innerHTML = marked.parse(fullResponse);
                                document.getElementById("chatHistory").scrollTop = document.getElementById("chatHistory").scrollHeight;
                            }
                        } catch (e) {
                            console.error("Failed to parse JSON chunk:", e, "Chunk:", data);
                        }
                    }
                }
            }

            const placeholderIndex = chatSessions[currentChatId].findIndex((msg, index) => `message-${index}` === placeholderId);
            if (placeholderIndex !== -1) {
                const newContent = { content: fullResponse };
                // Initialize generations array if it doesn't exist, otherwise push to it
                if (!chatSessions[currentChatId][placeholderIndex].generations) {
                    chatSessions[currentChatId][placeholderIndex].generations = [newContent];
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = 0;
                } else {
                    chatSessions[currentChatId][placeholderIndex].generations.push(newContent);
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = chatSessions[currentChatId][placeholderIndex].generations.length - 1;
                }
                chatSessions[currentChatId][placeholderIndex].content = 'GENERATED'; // Mark as generated
                updateMessageElement(placeholderId, chatSessions[currentChatId][placeholderIndex]);
            }
            saveChatSessions();
        } else {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiToken}`
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.details.error.message}`);
            }

            const data = await response.json();
            let aiMessageContent = data.choices[0].message.content;

            const imageUrlRegex = /(https:\/\/image\.pollinations\.ai\/prompt\/.*)/g;
            if (imageUrlRegex.test(aiMessageContent)) {
                const imageUrl = aiMessageContent.match(imageUrlRegex)[0];
                const finalImageUrl = addDefaultUrlParams(imageUrl, requestBody.seed);
                aiMessageContent = `![Generated image](${finalImageUrl})`;
            }

            const placeholderIndex = chatSessions[currentChatId].findIndex((msg, index) => `message-${index}` === placeholderId);
            if (placeholderIndex !== -1) {
                const newContent = { content: aiMessageContent };
                // Initialize generations array if it doesn't exist, otherwise push to it
                if (!chatSessions[currentChatId][placeholderIndex].generations) {
                    chatSessions[currentChatId][placeholderIndex].generations = [newContent];
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = 0;
                } else {
                    chatSessions[currentChatId][placeholderIndex].generations.push(newContent);
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = chatSessions[currentChatId][placeholderIndex].generations.length - 1;
                }
                chatSessions[currentChatId][placeholderIndex].content = 'GENERATED'; // Mark as generated
                updateMessageElement(placeholderId, chatSessions[currentChatId][placeholderIndex]);
            }
            
            saveChatSessions();
        }
    }

    async function handleGroqApiCall(model, streamingEnabled, apiMessages, placeholderId) {
        const apiUrl = "https://api.groq.com/openai/v1/chat/completions";

        const requestBody = {
            "model": model,
            "messages": apiMessages,
            "stream": streamingEnabled,
            "temperature": 0.7,
        };

        const processGroqResponse = (fullResponse) => {
            let content = fullResponse;
            let thinkingContent = null;
            
            // Regex to find content inside <think> tags, handling both plain and unicode
            const thinkRegex = /(\u003cthink\u003e|\<think\>)(.*?)(\u003c\/think\u003e|\<\/think\>)/s;
            const match = content.match(thinkRegex);
            
            if (match) {
                thinkingContent = match[2].trim();
                // Remove the entire <think> block from the main content
                content = content.replace(match[0], '').trim();
            }

            return { content, thinkingContent };
        };

        if (streamingEnabled) {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${GROQ_API_KEY}`
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.error.message}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder("utf-8");
            let fullResponse = "";
            const messageElement = document.getElementById(placeholderId);
            if (!messageElement) throw new Error("Could not find message element for streaming.");
            
            const loadingDots = messageElement.querySelector('.loading-dots');
            const streamingContent = messageElement.querySelector('.streaming-content');
            let isFirstChunk = true;

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                const lines = chunk.split("\n");
                for (const line of lines) {
                    if (line.startsWith("data: ")) {
                        const data = line.substring(6);
                        if (data === "[DONE]") continue;
                        try {
                            const json = JSON.parse(data);
                            if (json.choices && json.choices[0].delta && json.choices[0].delta.content) {
                                if (isFirstChunk) {
                                    if (loadingDots) {
                                        loadingDots.remove();
                                    }
                                    isFirstChunk = false;
                                }
                                fullResponse += json.choices[0].delta.content;
                                streamingContent.innerHTML = marked.parse(fullResponse);
                                document.getElementById("chatHistory").scrollTop = document.getElementById("chatHistory").scrollHeight;
                            }
                        } catch (e) {
                            console.error("Failed to parse JSON chunk:", e, "Chunk:", data);
                        }
                    }
                }
            }

            const { content, thinkingContent } = processGroqResponse(fullResponse);
            
            const placeholderIndex = chatSessions[currentChatId].findIndex((msg, index) => `message-${index}` === placeholderId);
            if (placeholderIndex !== -1) {
                const newContent = { content, thinkingContent };
                if (!chatSessions[currentChatId][placeholderIndex].generations) {
                    chatSessions[currentChatId][placeholderIndex].generations = [newContent];
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = 0;
                } else {
                    chatSessions[currentChatId][placeholderIndex].generations.push(newContent);
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = chatSessions[currentChatId][placeholderIndex].generations.length - 1;
                }
                chatSessions[currentChatId][placeholderIndex].content = 'GENERATED'; // Mark as generated
                updateMessageElement(placeholderId, chatSessions[currentChatId][placeholderIndex]);
            }
            saveChatSessions();
        } else {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${GROQ_API_KEY}`
                },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.error.message}`);
            }

            const data = await response.json();
            const aiMessageFullContent = data.choices[0].message.content;

            const { content, thinkingContent } = processGroqResponse(aiMessageFullContent);

            const placeholderIndex = chatSessions[currentChatId].findIndex((msg, index) => `message-${index}` === placeholderId);
            if (placeholderIndex !== -1) {
                const newContent = { content, thinkingContent };
                if (!chatSessions[currentChatId][placeholderIndex].generations) {
                    chatSessions[currentChatId][placeholderIndex].generations = [newContent];
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = 0;
                } else {
                    chatSessions[currentChatId][placeholderIndex].generations.push(newContent);
                    chatSessions[currentChatId][placeholderIndex].currentGenerationIndex = chatSessions[currentChatId][placeholderIndex].generations.length - 1;
                }
                chatSessions[currentChatId][placeholderIndex].content = 'GENERATED'; // Mark as generated
                updateMessageElement(placeholderId, chatSessions[currentChatId][placeholderIndex]);
            }
            
            saveChatSessions();
        }
    }

function constructApiMessages(isGroq, userMessage) {
    let currentHistory = chatSessions[currentChatId] || [];
    const selectedModel = document.getElementById("modelSelect").value;
    
    // Initialize messages array (skip system message for Unity model)
    let apiMessages = [];
    if (selectedModel !== "unity") {
        apiMessages.push({
            "role": "system",
            "content": "You are a helpful assistant. Your name is AeosAI. Please respond in easy-to-read and concise messages and use Markdown to make your point easy to understand."
        });
    }

    // Add conversation history up to the point of the current user message
    for(const msg of currentHistory) {
        if (msg.role === 'user') {
            if (msg.imageData && !isGroq) {
                apiMessages.push({
                    "role": "user",
                    "content": [
                        { "type": "text", "text": msg.content },
                        { "type": "image_url", "image_url": { "url": msg.imageData.data } }
                    ]
                });
            } else {
                apiMessages.push({
                    "role": "user",
                    "content": msg.content
                });
            }
        } else if (msg.role === 'assistant' && msg.content !== 'loading' && msg.content !== 'streaming_loading') {
            const currentGeneration = msg.generations && msg.generations[msg.currentGenerationIndex] ? msg.generations[msg.currentGenerationIndex] : { content: msg.content, thinkingContent: msg.thinkingContent };
            let assistantContent = currentGeneration.content;
            if (currentGeneration.thinkingContent) {
                assistantContent += `\n\n<think>${currentGeneration.thinkingContent}</think>`;
            }
            apiMessages.push({
                "role": "assistant",
                "content": assistantContent
            });
        }
        // Stop adding messages once we reach the user message that is being regenerated
        if (msg === userMessage) {
            break;
        }
    }
    
    return apiMessages;
}

async function regenerateResponse(messageId) {
    const messageElement = document.getElementById(messageId);
    if (!messageElement) {
        showCustomAlert("Error: Cannot find the message to regenerate.");
        return;
    }
    
    const messageIndex = Array.from(messageElement.parentNode.children).indexOf(messageElement);
    const currentHistory = chatSessions[currentChatId];
    
    const userMessageIndex = messageIndex - 1;
    if (userMessageIndex < 0 || currentHistory[userMessageIndex].role !== 'user') {
        showCustomAlert("Cannot regenerate a response without a preceding user message.");
        return;
    }
    
    const originalAssistantMessage = currentHistory[messageIndex];
    const userMessage = currentHistory[userMessageIndex];

    messageElement.innerHTML = `
        <p class="font-bold mb-1">AeosAI:</p>
        <div class="streaming-content markdown-body">
            <div class="loading-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    `;

    const submitButton = document.getElementById("submitButton");
    submitButton.disabled = true;
    submitButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';

    const model = document.getElementById("modelSelect").value;
    const streamingEnabled = document.getElementById("streamingSwitch").checked;
    const selectedModelDetails = models.find(m => m.name === model);
    const isGroqModel = selectedModelDetails && selectedModelDetails.type === "groq";

    const apiUrl = isGroqModel ? "https://api.groq.com/openai/v1/chat/completions" : "https://text.pollinations.ai/openai";
    const apiToken = isGroqModel ? GROQ_API_KEY : "G8f6YS3lJnS7KK2I";
    
    const apiMessages = constructApiMessages(isGroqModel, userMessage);

    const requestBody = {
        "model": model,
        "messages": apiMessages,
        "stream": streamingEnabled,
        "temperature": 0.7
    };

    if (!isGroqModel) {
        // Add seed parameter only for Pollinations.ai API
        let seed = parseInt(localStorage.getItem('seed')) || 1;
        seed++;
        localStorage.setItem('seed', seed);
        requestBody.seed = seed;
    }
    
    try {
        const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${apiToken}`
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.error ? errorData.error.message : (errorData.details ? errorData.details.error.message : 'Unknown error')}`);
        }

        let newContent = "";
        let newThinkingContent = null;
        
        if (streamingEnabled) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder("utf-8");
            
            const streamingContentDiv = messageElement.querySelector('.streaming-content');
            let isFirstChunk = true;
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                const lines = chunk.split("\n");
                for (const line of lines) {
                    if (line.startsWith("data: ")) {
                        const data = line.substring(6);
                        if (data === "[DONE]") continue;
                        try {
                            const json = JSON.parse(data);
                            if (json.choices && json.choices[0].delta && json.choices[0].delta.content) {
                                if (isFirstChunk) {
                                    streamingContentDiv.innerHTML = '';
                                    isFirstChunk = false;
                                }
                                newContent += json.choices[0].delta.content;
                                streamingContentDiv.innerHTML = marked.parse(newContent);
                                document.getElementById("chatHistory").scrollTop = document.getElementById("chatHistory").scrollHeight;
                            }
                        } catch (e) {
                            console.error("Failed to parse JSON chunk:", e, "Chunk:", data);
                        }
                    }
                }
            }
        } else {
            const data = await response.json();
            newContent = data.choices[0].message.content;
        }

        const thinkRegex = /(\u003cthink\u003e|\<think\>)(.*?)(\u003c\/think\u003e|\<\/think\>)/s;
        const match = newContent.match(thinkRegex);
        if (match) {
            newThinkingContent = match[2].trim();
            newContent = newContent.replace(match[0], '').trim();
        }

        if (!originalAssistantMessage.generations) {
            originalAssistantMessage.generations = [
                { content: originalAssistantMessage.content, thinkingContent: originalAssistantMessage.thinkingContent }
            ];
            originalAssistantMessage.currentGenerationIndex = 0;
        }
        
        originalAssistantMessage.generations.push({ content: newContent, thinkingContent: newThinkingContent });
        originalAssistantMessage.currentGenerationIndex = originalAssistantMessage.generations.length - 1;
        
        originalAssistantMessage.content = 'GENERATED'; 
        
        updateMessageElement(messageId, originalAssistantMessage);
        saveChatSessions();

    } catch (error) {
        showCustomAlert(`Regeneration failed: ${error.message}`);
        updateMessageElement(messageId, originalAssistantMessage);
    } finally {
        submitButton.disabled = false;
        submitButton.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
    }
}


    function showPreviousGeneration(messageId) {
        const messageElement = document.getElementById(messageId);
        const messageIndex = Array.from(messageElement.parentNode.children).indexOf(messageElement);
        const message = chatSessions[currentChatId][messageIndex];

        if (message.currentGenerationIndex > 0) {
            message.currentGenerationIndex--;
            updateMessageElement(messageId, message);
            saveChatSessions();
        }
    }

    function showNextGeneration(messageId) {
        const messageElement = document.getElementById(messageId);
        const messageIndex = Array.from(messageElement.parentNode.children).indexOf(messageElement);
        const message = chatSessions[currentChatId][messageIndex];

        if (message.currentGenerationIndex < message.generations.length - 1) {
            message.currentGenerationIndex++;
            updateMessageElement(messageId, message);
            saveChatSessions();
        }
    }


    function showCustomAlert(message) {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50';
      modal.innerHTML = `
        <div class="bg-slate-800 p-6 rounded-lg shadow-xl text-white max-w-sm w-full mx-4">
          <p class="text-lg font-bold mb-4">Warning</p>
          <p class="mb-6">${message}</p>
          <button class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded-lg" onclick="this.parentNode.parentNode.remove()">OK</button>
        </div>
      `;
      document.body.appendChild(modal);
    }

    function convertImageToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file);
        });
    }

    const imageInput = document.getElementById('imageInput');
    const imageAttachButton = document.getElementById('imageAttachButton');
    const imagePreviewContainer = document.getElementById('imagePreviewContainer');
    const imagePreview = document.getElementById('imagePreview');
    const imageFileName = document.getElementById('imageFileName');
    const removeImageButton = document.getElementById('removeImageButton');

    imageAttachButton.addEventListener('click', () => {
        if (!imageAttachButton.classList.contains('disabled')) {
            imageInput.click();
        }
    });

    imageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.src = e.target.result;
                imageFileName.textContent = file.name;
                imagePreviewContainer.classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }
    });

    removeImageButton.addEventListener('click', () => {
        imageInput.value = '';
        imagePreviewContainer.classList.add('hidden');
        imagePreview.src = '';
        imageFileName.textContent = '';
    });
    
    const micButton = document.getElementById('micButton');
    const micButtonIcon = micButton.querySelector('i');
    const audioVisualizerContainer = document.getElementById('audioVisualizerContainer');
    const visualizerCanvas = document.getElementById('audioVisualizerCanvas');
    const messageInput = document.getElementById('messageInput');
    const canvasContext = visualizerCanvas.getContext('2d');
    
    let audioContext;
    let analyser;
    let microphoneStream;
    let animationFrameId;

    let mediaRecorder;
    let audioChunks = [];
    const GROQ_API_KEY = "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";

    function resizeCanvas() {
        visualizerCanvas.width = window.innerWidth;
        visualizerCanvas.height = window.innerHeight;
    }

    async function startListening() {
        try {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphoneStream = stream;

            audioVisualizerContainer.classList.add('show');
            micButtonIcon.classList.add('mic-recording');
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const drawVisualizer = () => {
                animationFrameId = requestAnimationFrame(drawVisualizer);
                analyser.getByteFrequencyData(dataArray);
                canvasContext.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                const centerX = visualizerCanvas.width / 2;
                const centerY = visualizerCanvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;
                
                let overallAmplitude = 0;
                for (let i = 0; i < 64; i++) {
                    overallAmplitude += dataArray[i];
                }
                overallAmplitude = (overallAmplitude / 64) / 256;
                const coreRadius = radius * 0.2 + radius * 0.1 * overallAmplitude;

                canvasContext.beginPath();
                canvasContext.arc(centerX, centerY, coreRadius, 0, 2 * Math.PI);
                canvasContext.fillStyle = `hsl(210, 80%, ${50 + overallAmplitude * 20}%)`;
                canvasContext.fill();
                canvasContext.closePath();

                const numPoints = 128;
                const innerRadius = radius * 0.25;
                const outerRadius = radius * 0.8;

                canvasContext.beginPath();
                canvasContext.lineWidth = 3;
                canvasContext.lineCap = 'round';

                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const freqIndex = Math.floor((i / numPoints) * bufferLength);
                    const amplitude = dataArray[freqIndex] / 256;
                    const currentRadius = innerRadius + (outerRadius - innerRadius) * amplitude;

                    const x = centerX + Math.cos(angle) * currentRadius;
                    const y = centerY + Math.sin(angle) * currentRadius;

                    if (i === 0) {
                        canvasContext.moveTo(x, y);
                    } else {
                        canvasContext.lineTo(x, y);
                    }
                }
                canvasContext.closePath();

                const gradient = canvasContext.createLinearGradient(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                gradient.addColorStop(0, '#60a5fa');
                gradient.addColorStop(0.5, '#c084fc');
                gradient.addColorStop(1, '#a78bfa');
                canvasContext.strokeStyle = gradient;
                canvasContext.stroke();
            };

            drawVisualizer();

            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { 'type' : 'audio/webm' });
                await sendAudioForTranscription(audioBlob);
            };

            mediaRecorder.start();

        } catch (err) {
            console.error('Error accessing the microphone:', err);
            showCustomAlert('Error: Could not access the microphone. Please check your browser permissions.');
            audioVisualizerContainer.classList.remove('show');
            micButtonIcon.classList.remove('mic-recording');
        }
    }
    
    function stopListening() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
            mediaRecorder.stop();
        }

        window.removeEventListener('resize', resizeCanvas);
        if (microphoneStream) {
            microphoneStream.getTracks().forEach(track => track.stop());
            if (audioContext) {
                audioContext.close();
            }
            cancelAnimationFrame(animationFrameId);
        }
        audioVisualizerContainer.classList.remove('show');
        micButtonIcon.classList.remove('mic-recording');
        canvasContext.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
    }

    async function sendAudioForTranscription(audioBlob) {
        const transcriptionApiUrl = "https://api.groq.com/openai/v1/audio/transcriptions";

        const formData = new FormData();
        formData.append("file", audioBlob, "audio.webm");
        formData.append("model", "whisper-large-v3-turbo");
        formData.append("temperature", "0");
        formData.append("response_format", "json");
        formData.append("language", "en");

        messageInput.placeholder = "Transcribing audio...";
        micButtonIcon.classList.remove('fa-microphone');
        micButtonIcon.classList.add('fa-spinner', 'fa-spin');

        try {
            const response = await fetch(transcriptionApiUrl, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${GROQ_API_KEY}`
                },
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`HTTP error! status: ${response.status}. Details: ${errorData.error.message}`);
            }

            const data = await response.json();
            if (data.text) {
                messageInput.value = data.text;
                messageInput.placeholder = "Type a message...";
            } else {
                messageInput.placeholder = "Transcription failed.";
            }

        } catch (error) {
            console.error("Transcription API call failed:", error);
            showCustomAlert(`Transcription failed: ${error.message}`);
            messageInput.placeholder = "Transcription failed.";
        } finally {
            micButtonIcon.classList.remove('fa-spinner', 'fa-spin');
            micButtonIcon.classList.add('fa-microphone');
        }
    }

    micButton.addEventListener('click', () => {
        if (audioVisualizerContainer.classList.contains('show')) {
            stopListening();
        } else {
            startListening();
        }
    });
    audioVisualizerContainer.addEventListener('click', stopListening);

    document.getElementById('closeModalButton').addEventListener('click', () => {
        document.getElementById('imageModal').classList.add('hidden');
    });

    document.getElementById('downloadButton').addEventListener('click', async () => {
        const imageUrl = document.getElementById('modalImage').src;
        try {
            const response = await fetch(imageUrl);
            const blob = await response.blob();
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `pollinations_ai_image_${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        } catch (error) {
            console.error('Error downloading the image:', error);
            showCustomAlert('Failed to download the image.');
        }
    });

    const modelSelect = document.getElementById('modelSelect');
    modelSelect.addEventListener('change', (event) => {
        const selectedModel = event.target.value;
        const selectedModelDetails = models.find(m => m.name === selectedModel);
        if (selectedModelDetails && selectedModelDetails.type === 'groq') {
            imageAttachButton.disabled = true;
            imageAttachButton.classList.add('disabled');
            if (imageInput.files.length > 0) {
                removeImageButton.click();
            }
        } else {
            imageAttachButton.disabled = false;
            imageAttachButton.classList.remove('disabled');
        }
    });

window.addEventListener('DOMContentLoaded', () => {
    populateModelSelect();
    loadChatSessions();
    document.getElementById('messageForm').addEventListener('submit', submitForm);
    document.getElementById('newChatButton').addEventListener('click', createNewChat);
    initAdvancedMode();
    modelSelect.dispatchEvent(new Event('change'));
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoonSec V3 Lua Deobfuscator - Full Extraction</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .input-section, .output-section {
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            height: 300px;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }
        .error {
            color: #e74c3c;
            margin-top: 10px;
            display: none;
        }
        .log {
            color: #27ae60;
            margin-top: 10px;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MoonSec V3 Lua Deobfuscator - Full Extraction</h1>
        <div class="input-section">
            <div class="label">Paste Obfuscated Lua Code (MoonSec V3):</div>
            <textarea id="inputCode" placeholder="Paste your obfuscated Lua code here..."></textarea>
        </div>
        <button onclick="deobfuscate()">Deobfuscate & Extract Script</button>
        <div class="output-section">
            <div class="label">Extracted Lua Script:</div>
            <textarea id="outputCode" readonly placeholder="Deobfuscated and extracted script will appear here..."></textarea>
            <div id="errorMessage" class="error">An error occurred during deobfuscation. Please check your input code.</div>
            <div id="logMessage" class="log"></div>
        </div>
    </div>

    <script>
        let transformationLog = [];

        function deobfuscate() {
            const inputCode = document.getElementById('inputCode').value.trim();
            const outputCodeElement = document.getElementById('outputCode');
            const errorMessageElement = document.getElementById('errorMessage');
            const logMessageElement = document.getElementById('logMessage');

            if (!inputCode) {
                errorMessageElement.style.display = 'block';
                errorMessageElement.textContent = 'Please enter some code to deobfuscate.';
                logMessageElement.textContent = '';
                outputCodeElement.value = '';
                return;
            }

            try {
                errorMessageElement.style.display = 'none';
                transformationLog = [];
                const deobfuscated = processMoonSecV3(inputCode);
                outputCodeElement.value = deobfuscated;
                logMessageElement.textContent = transformationLog.length > 0 
                    ? "Transformations Applied:\n" + transformationLog.join('\n')
                    : "No significant transformations applied. Possible advanced VM or runtime encryption detected.";
            } catch (e) {
                errorMessageElement.style.display = 'block';
                errorMessageElement.textContent = 'Error during deobfuscation: ' + e.message;
                logMessageElement.textContent = '';
                outputCodeElement.value = '';
            }
        }

        function processMoonSecV3(code) {
            if (code.length > 2000000) {
                throw new Error("Input code is too long. Please limit to 2MB or less for processing.");
            }

            transformationLog.push("Starting multi-pass deobfuscation to extract core script...");

            // Pass 1: Aggressive string decryption
            code = decryptStrings(code, 3); // Multiple iterations for nested encodings

            // Pass 2: Simplify identifiers aggressively
            code = simplifyNames(code);

            // Pass 3: Unravel control flow with deep nesting support
            code = unravelControlFlow(code, 2); // Multiple passes for nested structures

            // Pass 4: Simplify tables and constants with deep analysis
            code = simplifyStructures(code);

            // Pass 5: Speculative VM decoding and payload extraction
            code = extractPayload(code);

            // Pass 6: Clean up and format for readability
            code = formatCode(code);

            transformationLog.push("Deobfuscation complete. Review output for extracted script logic.");
            return code;
        }

        function decryptStrings(code, iterations) {
            let newCode = code;
            let decodedCount = 0;

            // Iterative decoding for nested or complex string obfuscation
            for (let i = 0; i < iterations; i++) {
                let tempCode = newCode;

                // Byte array tables {104, 101, ...} -> "hello"
                const byteTablePattern = /\{(?:\d+,?\s*){2,}\}/g;
                newCode = newCode.replace(byteTablePattern, (match) => {
                    try {
                        const numbers = match.match(/\d+/g).map(Number);
                        let decoded = '';
                        for (let num of numbers) {
                            if (num >= 0 && num <= 255) decoded += String.fromCharCode(num);
                        }
                        if (decoded) {
                            decodedCount++;
                            return `"${decoded}"`;
                        }
                        return match;
                    } catch (e) {
                        return match;
                    }
                });

                // Bitwise operations for character encoding
                const bitwisePattern = /\(\s*(\d+)\s*([\~\&\|])\s*(\d+)\s*\)/g;
                newCode = newCode.replace(bitwisePattern, (match, a, op, b) => {
                    try {
                        a = parseInt(a);
                        b = parseInt(b);
                        let result;
                        if (op === '~') result = a ^ b;
                        else if (op === '&') result = a & b;
                        else if (op === '|') result = a | b;
                        if (result >= 0 && result <= 255) {
                            decodedCount++;
                            return `"${String.fromCharCode(result)}"`;
                        }
                        return match;
                    } catch (e) {
                        return match;
                    }
                });

                // String fragment concatenation
                const concatPattern = /"([^"]*)"\s*\.\.\s*"([^"]*)"/g;
                newCode = newCode.replace(concatPattern, (match, a, b) => {
                    decodedCount++;
                    return `"${a + b}"`;
                });

                // Stop if no changes in this iteration
                if (tempCode === newCode) break;
            }

            transformationLog.push(`- Decoded ${decodedCount} string patterns (byte tables, bitwise ops, concatenations)`);
            return newCode;
        }

        function simplifyNames(code) {
            const namePattern = /[a-zA-Z_][a-zA-Z0-9_]{6,}/g;
            const usedNames = new Map();
            let counter = 1;

            const newCode = code.replace(namePattern, (match) => {
                if (!usedNames.has(match)) {
                    usedNames.set(match, `x${counter++}`);
                }
                return usedNames.get(match);
            });

            transformationLog.push(`- Simplified ${usedNames.size} long identifiers to short names`);
            return newCode;
        }

        function unravelControlFlow(code, passes) {
            let newCode = code;
            let changes = 0;

            for (let i = 0; i < passes; i++) {
                let tempCode = newCode;

                // Remove junk loops and conditions
                const junkControlPattern = /(?:while|if)\s+(?:true|false)\s+(?:do|then)\s*(?:break|return\s*[^;]*;)\s*end/g;
                newCode = newCode.replace(junkControlPattern, () => {
                    changes++;
                    return '';
                });

                // Unwrap immediate function calls
                const funcWrapperPattern = /\(function\s*\(\s*[\w\d,]*\s*\)\s*([\s\S]*?)\s*end\s*\)\s*\(\s*[\w\d,]*\s*\)/g;
                newCode = newCode.replace(funcWrapperPattern, (match, body) => {
                    changes++;
                    return body;
                });

                // Simplify redundant conditionals
                const redundantIfPattern = /if\s+([\w\d]+)\s+then\s*([\s\S]*?)\s*end/g;
                newCode = newCode.replace(redundantIfPattern, (match, cond, body) => {
                    if (body.trim().split('\n').length < 3) {
                        changes++;
                        return `if ${cond} then ${body.trim()}; end`;
                    }
                    return match;
                });

                if (tempCode === newCode) break;
            }

            transformationLog.push(`- Unraveled control flow with ${changes} simplifications (loops, wrappers, conditionals)`);
            return newCode;
        }

        function simplifyStructures(code) {
            let newCode = code;
            let changes = 0;

            // Simplify table accesses
            const tableAccessPattern = /(?:_G|[\w\d]+)(?:\s*\[\s*["']?([\w\d]+)["']?\s*\]){1,}/g;
            newCode = newCode.replace(tableAccessPattern, (match, key) => {
                changes++;
                return key;
            });

            // Fold constants (math operations)
            const mathPattern = /(\d+)\s*([\+\-\*\/])\s*(\d+)/g;
            newCode = newCode.replace(mathPattern, (match, a, op, b) => {
                try {
                    a = parseFloat(a);
                    b = parseFloat(b);
                    let result;
                    if (op === '+') result = a + b;
                    else if (op === '-') result = a - b;
                    else if (op === '*') result = a * b;
                    else if (op === '/') result = b !== 0 ? a / b : match;
                    if (result !== match) {
                        changes++;
                        return result.toString();
                    }
                    return match;
                } catch (e) {
                    return match;
                }
            });

            // Remove junk locals and tables
            const junkLocalPattern = /local\s+[\w\d]+\s*=\s*(?:\{\s*\}|nil)\s*;/g;
            newCode = newCode.replace(junkLocalPattern, () => {
                changes++;
                return '';
            });

            transformationLog.push(`- Simplified ${changes} structural elements (tables, constants, junk locals)`);
            return newCode;
        }

        function extractPayload(code) {
            let newCode = code;
            let extracted = false;

            // Detect and extract potential payload from VM-like structures or loader functions
            const loaderPattern = /function\s*\(\s*[\w\d,]*\s*\)\s*([\s\S]*?)\s*end\s*\(\s*[\w\d,]*\s*\)/g;
            let loaderMatch = loaderPattern.exec(newCode);
            if (loaderMatch && loaderMatch[1]) {
                extracted = true;
                let payload = loaderMatch[1].trim();
                newCode = `-- Extracted payload from loader function\n${payload}`;
                transformationLog.push(`- Extracted potential core script from loader function`);
            }

            // Detect large data tables (often VM instructions or encrypted payload)
            const dataTablePattern = /local\s+[\w\d]+\s*=\s*\{\s*(\d+\s*,\s*){10,}\s*\d+\s*\}\s*;/g;
            if (dataTablePattern.test(newCode) && !extracted) {
                newCode = newCode.replace(dataTablePattern, (match) => {
                    transformationLog.push(`- Detected large data table (possible VM instructions or payload); simplified`);
                    return `-- Simplified data table (potential payload or VM code)\nlocal data = {/* ... omitted ... */};`;
                });

                // Attempt speculative decoding of payload if it looks like encoded bytes
                const byteDataPattern = /\{\s*(\d+\s*,\s*){10,}\s*\d+\s*\}/g;
                let byteMatch = byteDataPattern.exec(newCode);
                if (byteMatch) {
                    let numbers = byteMatch[0].match(/\d+/g).map(Number);
                    let decodedPayload = '';
                    for (let num of numbers) {
                        if (num >= 0 && num <= 255) decodedPayload += String.fromCharCode(num);
                    }
                    if (decodedPayload.length > 50) {
                        newCode += `\n\n-- Speculative payload decode (may not be valid Lua):\n--[[${decodedPayload.slice(0, 200)}...]]`;
                        transformationLog.push(`- Speculatively decoded data table as potential payload (partial display)`);
                        extracted = true;
                    }
                }
            }

            // If no payload extracted, look for deeply nested function bodies as the core script
            if (!extracted) {
                const nestedFuncPattern = /(?:function\s*\(\s*[\w\d,]*\s*\)\s*){2,}([\s\S]*?)(?:end\s*){2,}/g;
                let nestedMatch = nestedFuncPattern.exec(newCode);
                if (nestedMatch && nestedMatch[1]) {
                    let coreLogic = nestedMatch[1].trim();
                    newCode = `-- Extracted core logic from nested functions\n${coreLogic}`;
                    transformationLog.push(`- Extracted core script logic from deeply nested functions`);
                    extracted = true;
                }
            }

            // Final fallback: Strip known obfuscation layers and assume remainder is payload
            if (!extracted) {
                const obfuscationLayerPattern = /local\s+[\w\d]+\s*=\s*function\s*\([\s\S]*?end\s*;/g;
                newCode = newCode.replace(obfuscationLayerPattern, () => {
                    return `-- Obfuscation layer removed`;
                });
                transformationLog.push(`- Stripped outer obfuscation layers; remaining code assumed to be core script`);
            }

            return newCode;
        }

        function formatCode(code) {
            let formatted = '';
            let indentLevel = 0;
            const indentSize = 2;
            const lines = code.split('\n');

            for (let line of lines) {
                line = line.trim();
                if (!line) continue;

                if (line.match(/\b(end|else|elseif)\b/)) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }

                try {
                    formatted += ' '.repeat(indentLevel * indentSize) + line + '\n';
                } catch (e) {
                    formatted += line + '\n';
                }

                if (line.match(/\b(do|then|function)\b/)) {
                    indentLevel++;
                }
            }

            transformationLog.push(`- Formatted code for readability`);
            return formatted;
        }
    </script>
</body>
</html>
